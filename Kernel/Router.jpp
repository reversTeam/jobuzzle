/**************************************************************
*     ####         #                               #          * Jobuzzle - Copyright All rights reserved
*     ####         #                               #          *
*       ##  #####  ######  #     # ####### ####### #  #####   * @Author: revers
*       ## #     # #     # #     #      #       #  # #     #  *
*       ## #     # #     # #     #     #       #   # #     #  * @Date:   2015-08-08 11:13:11
*       ## #     # #     # #     #    #       #    # #     #  *
*       ## #     # #     # #     #   #       #     # ######   * @Last Modified by:   revers
*  ####### #     # #     # #     #  #       #      # #        *
*  ######   #####   ######  #####  ####### ####### # #######  * @Last Modified time: 2015-08-08 14:33:59
**************************************************************/

#import ('./Route/MasterRoute') = MasterRoute;
#import ('./Utility') = Utility;

class Router {

	initialize : function () {
		this._routes = {};
	}

	addRoute : function (name, routes) {
		if (!name || !routes)
			throw 'You can\'t add empty route name or routes';
		if (routes instanceof MasterRoute) {
			this._routes[name] = this.buildRoute(name, routes);
		}
		else 
			this._routes[name] = routes;
	}

	getRoute : function (name) {
		if (!name)
			throw 'You can\'t get route empty name';
		return this._routes[name];
	}

	getRoutes : function () {
		return this._routes;
	}

	build : function (str, datas) {
		str = str.substr(1);
		var segments = str.split('/');
		var routes = this.getRoutes();
		var result = this.buildRecusiveRoute(segments, routes, datas, 0);

		return result;
	}

	buildRoute : function (key, cur) {
		var routes = {};

		if (cur instanceof MasterRoute)
			routes = cur.getRoutes();
		else {
			routes = cur;
			cur = null;
		}
		if (!routes.type)
			throw 'Cannot determined type for your route';
		var req = Utility.require(Config['path'] + '/Kernel/Route/Type/'+ routes.type +'RouteType');
		return new req(key, routes, cur);
	}

	match : function (str) {
		str = str.substr(1);
		var segments = str.split('/');
		var routes = this.getRoutes();
		var result = this.matchRecusiveRoute(segments, routes, 0);

		return result;
	}

	buildRecusiveRoute : function (segments, routes, datas, index) {
		var buildResult = undefined;
		var childResult = undefined;

		for (var i in routes) {
			buildResult = routes[i].build(segments[index], datas);
			if (buildResult && segments[index + 1]) {
				childResult = this.buildRecusiveRoute(segments, routes[i].getRoutes(), datas, index + 1);
				if (childResult)
					return '/'+ buildResult + childResult;
			} else if (buildResult)
				return '/'+ buildResult;
		}
		return false;
	}

	matchRecusiveRoute : function (segments, routes, index) {
		var result = {};
		var match = undefined;

		for (var i in routes) {
			match = routes[i].match(segments[index]);
			if (match && (segments[index + 1])) {
				return this.concatResultMatch(match, this.matchRecusiveRoute(segments, routes[i].getRoutes(), index + 1));
			} else if (match) {
				if (match !== true)
					result = match;
				result['actions'] = {};
				result['actions']['controller'] = routes[i].getController();
				result['actions']['method'] = routes[i].getMethod();
				return result;
			}
		}
		return false;
	}

	concatResultMatch : function (tab1, tab2) {
		if (!tab2)
			return false;
		if (tab2 == true)
			return tab1;
		if (tab1 == true)
			return tab2;
		for (var i in tab2) {
			tab1[i] = tab2[i];
		}
		return tab1;
	} 

}

#export Router;